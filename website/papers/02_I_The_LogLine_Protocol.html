<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The 9-field tuple. Ghost records. Threat model. The core mechanism for accountability.">
    <meta name="keywords" content="LogLine, accountability, security, protocol, the logline protocol">
    <title>The LogLine Protocol - LogLine Foundation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0a0a;
            --text-light: #e8e8e8;
            --accent: #4a9eff;
            --border: #2a2a2a;
            --code-bg: #151515;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-light);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.8;
            font-size: 16px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 0 40px;
        }

        /* Header */
        header {
            padding: 60px 0 40px;
            border-bottom: 1px solid var(--border);
        }

        .back-link {
            display: inline-block;
            color: var(--accent);
            text-decoration: none;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .paper-number {
            font-family: 'Courier New', monospace;
            color: var(--accent);
            font-weight: 700;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: var(--text-light);
        }

        .paper-meta {
            color: #999;
            font-size: 0.95rem;
            margin-top: 20px;
            padding: 20px;
            background-color: var(--code-bg);
            border-left: 3px solid var(--accent);
        }

        .paper-meta p {
            margin-bottom: 8px;
        }

        .paper-meta p:last-child {
            margin-bottom: 0;
        }

        /* Content */
        article {
            padding: 80px 0;
        }

        #markdown-content h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-top: 60px;
            margin-bottom: 25px;
            color: var(--text-light);
            line-height: 1.3;
        }

        #markdown-content h1:first-child {
            margin-top: 0;
        }

        #markdown-content h2 {
            font-size: 2rem;
            margin-top: 50px;
            margin-bottom: 20px;
            color: var(--text-light);
            line-height: 1.4;
        }

        #markdown-content h3 {
            font-size: 1.5rem;
            margin-top: 40px;
            margin-bottom: 15px;
            color: var(--text-light);
            line-height: 1.4;
        }

        #markdown-content h4 {
            font-size: 1.25rem;
            margin-top: 30px;
            margin-bottom: 12px;
            color: var(--text-light);
        }

        #markdown-content p {
            margin-bottom: 20px;
            color: #ccc;
            line-height: 1.8;
        }

        #markdown-content blockquote {
            font-style: italic;
            color: #aaa;
            padding: 25px 30px;
            border-left: 4px solid var(--accent);
            margin: 30px 0;
            background-color: var(--code-bg);
        }

        #markdown-content blockquote p {
            margin-bottom: 10px;
        }

        #markdown-content blockquote p:last-child {
            margin-bottom: 0;
        }

        #markdown-content hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 50px 0;
        }

        /* Code Blocks */
        #markdown-content pre {
            background-color: var(--code-bg);
            padding: 25px;
            margin: 25px 0;
            border: 1px solid var(--border);
            overflow-x: auto;
            border-radius: 4px;
        }

        #markdown-content code {
            font-family: 'Courier New', Monaco, monospace;
            font-size: 0.9rem;
        }

        #markdown-content pre code {
            color: #4a9eff;
        }

        #markdown-content p code,
        #markdown-content li code {
            background-color: var(--code-bg);
            color: var(--accent);
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        /* Lists */
        #markdown-content ul, 
        #markdown-content ol {
            margin-left: 30px;
            margin-bottom: 20px;
            margin-top: 10px;
        }

        #markdown-content li {
            margin-bottom: 12px;
            color: #ccc;
            line-height: 1.7;
        }

        #markdown-content li p {
            margin-bottom: 10px;
        }

        /* Tables */
        #markdown-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background-color: var(--code-bg);
        }

        #markdown-content th,
        #markdown-content td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border);
        }

        #markdown-content th {
            background-color: var(--border);
            color: var(--text-light);
            font-weight: 600;
        }

        #markdown-content td {
            color: #ccc;
        }

        #markdown-content strong {
            color: var(--text-light);
            font-weight: 600;
        }

        #markdown-content em {
            color: #bbb;
        }

        /* Links */
        a {
            color: var(--accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Footer */
        footer {
            padding: 40px 0;
            text-align: center;
            color: #666;
            border-top: 1px solid var(--border);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 0 20px;
            }

            h1 {
                font-size: 2rem;
            }

            #markdown-content h1 {
                font-size: 2rem;
            }

            #markdown-content h2 {
                font-size: 1.5rem;
            }

            #markdown-content h3 {
                font-size: 1.25rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <a href="../index.html" class="back-link">← Back to All Papers</a>
            <div class="paper-number">PAPER I</div>
            <h1>The LogLine Protocol</h1>
            <div class="paper-meta">
                <p><strong>Author:</strong> Dan Voulez</p>
                <p><strong>Institution:</strong> The LogLine Foundation</p>
                <p><strong>Version:</strong> 1.0.1</p>
                <p><strong>Date:</strong> 2026-02-05</p>
                <p><strong>Thesis:</strong> The log is not a record of execution. It is the prerequisite for execution.</p>
            </div>
        </div>
    </header>

    <article>
        <div class="container">
            <div id="markdown-content">
<h1>Paper I — The LogLine Protocol</h1>

<p><strong>The Atomic Unit of Verifiable Action</strong></p>

<p><em>Normative keywords per RFC 2119/8174 (MUST/SHOULD/MAY) apply.</em></p>

<hr>

<h2>The Story</h2>

<p><strong>March 2024. A major bank. $2.3 million gone in 47 minutes.</strong></p>

<p>The forensic team spent six weeks reconstructing what happened. The logs showed API calls. The logs showed timestamps. The logs showed nothing useful about <em>why</em> any of it was authorized.</p>

<p>The attacker had compromised an AI assistant. The assistant had legitimate access. Every request looked normal—individually. The pattern that would have revealed the attack was invisible because the logs recorded <em>what happened</em>, not <em>what was intended</em>.</p>

<p><strong>The attacker left no fingerprints because there was nowhere to leave them.</strong></p>

<p>Now imagine a different architecture.</p>

<p>Before the first transfer, the AI assistant would have been required to sign this:</p>

<pre><code>{
  "who": "did:logline:agent:assistant-7x3k",
  "did": "transfer",
  "this": {
    "from": "account:operating",
    "to": "account:external:9f8a2c",
    "amount": 47500,
    "currency": "USD"
  },
  "when": "2024-03-14T14:23:07.847Z",
  "confirmed_by": null,
  "if_ok": "emit:transfer.completed",
  "if_doubt": "escalate:treasury.human",
  "if_not": "emit:transfer.denied",
  "status": "pending"
}</code></pre>

<p>This LogLine would hit the policy engine. The policy would check:<br><ul><br><li>Agent trajectory score: 0.23 (new agent, low trust)</li><br><li>Transfer limit at this trajectory: $5,000</li><br><li>Requested amount: $47,500</li><br></ul></p>

<p><strong>Decision: REQUIRE</strong> — human confirmation needed.</p>

<p>The LogLine becomes a <strong>Ghost</strong>. It persists. Signed. Timestamped. Evidence that the attack was attempted.</p>

<p>One Ghost is an anomaly. Forty-seven Ghosts in 47 minutes from the same agent? That's an alarm.</p>

<p><strong>The attack fails because every attempt is a confession.</strong></p>

<p>This is the LogLine Protocol.</p>

<hr>

<h2>I. The Inversion</h2>

<p>Since 1945, every computing system has followed the same axiom:</p>

<pre><code>Code runs → Log writes</code></pre>

<p>Execution precedes registration. This gap between action and evidence is the root vulnerability of computation. In this gap:<br><ul><br><li>Logs are forged</li><br><li>Logs are deleted</li><br><li>Logs prove nothing about authorization</li><br><li>Logs provide no cryptographic binding</li><br></ul></p>

<p><strong>The LogLine Protocol inverts this relationship.</strong></p>

<pre><code>Log writes → Code runs</code></pre>

<p>Nothing happens unless it is first structured, signed, and committed as a LogLine.</p>

<p>The log is not a record of execution.<br><strong>The log is the prerequisite for execution.</strong></p>

<pre><code>// logline-core/src/runtime.rs
// This is real code. Install it: cargo install logline-cli

<p>use logline_core::{LogLine, Ledger, PolicyEngine, Decision};</p>

<p>pub struct Runtime {<br>    ledger: Ledger,<br>    policy: PolicyEngine,<br>}</p>

<p>impl Runtime {<br>    /// Execute an intent. The order is non-negotiable:<br>    /// 1. Create LogLine<br>    /// 2. Evaluate policy<br>    /// 3. Commit to ledger<br>    /// 4. THEN (and only then) execute<br>    pub fn execute(&amp;mut self, intent: Intent) -&gt; Result&lt;Receipt, ExecutionError&gt; {<br>        // Step 1: Create the LogLine (the intent becomes structured)<br>        let logline = LogLine::from_intent(&amp;intent)?;</p>

<p>// Step 2: Evaluate policy BEFORE any execution<br>        let decision = self.policy.evaluate(&amp;logline)?;</p>

<p>// Step 3: Commit to ledger (this happens regardless of decision)<br>        let committed = self.ledger.append(logline, &amp;decision)?;</p>

<p>// Step 4: Execute only if ALLOW<br>        match decision {<br>            Decision::Allow =&gt; {<br>                let effect = self.execute_effect(&amp;committed)?;<br>                Ok(Receipt::new(committed, effect))<br>            }<br>            Decision::Require { signers } =&gt; {<br>                // LogLine persists, waiting for consent<br>                Err(ExecutionError::ConsentRequired {<br>                    logline_cid: committed.cid(),<br>                    required_signers: signers,<br>                })<br>            }<br>            Decision::Deny { reason } =&gt; {<br>                // LogLine persists as Ghost<br>                Err(ExecutionError::Denied {<br>                    ghost_cid: committed.cid(),<br>                    reason,<br>                })<br>            }<br>        }<br>    }<br>}</code></pre></p>

<p>The critical insight: <strong>the ledger append happens before the decision branch</strong>. Whether allowed or denied, the intent is recorded. The execution happens only after.</p>

<hr>

<h2>II. The 9-Field Tuple</h2>

<p>Every action in a LogLine system is preceded by this structure:</p>

<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    THE LOGLINE TUPLE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  who           The actor                                        │
│                DID (did:method:id), Ed25519-bound               │
│                                                                 │
│  did           The verb                                         │
│                Canonical action from ALLOWED_ACTIONS registry   │
│                                                                 │
│  this          The payload                                      │
│                Typed JSON, validated against verb schema        │
│                                                                 │
│  when          The timestamp                                    │
│                ISO8601 UTC, nanosecond precision                │
│                                                                 │
│  confirmed_by  The consent                                      │
│                DID of approver (required for L3+ actions)       │
│                                                                 │
│  if_ok         Success commitment                               │
│                What happens when the action succeeds            │
│                                                                 │
│  if_doubt      Uncertainty protocol                             │
│                What happens on timeout or ambiguity             │
│                                                                 │
│  if_not        Failure commitment                               │
│                What happens when the action fails               │
│                                                                 │
│  status        Lifecycle state                                  │
│                DRAFT → PENDING → COMMITTED | GHOST              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘</code></pre>

<p>This structure is <strong>non-negotiable</strong>. Its rigidity is its security.</p>

<h3>The Pact</h3>

<p>These nine fields are not just a data structure. They are a <strong>contract</strong>.</p>

<pre><code>who         → I identify myself
did         → I declare my intention
this        → I specify the terms
when        → I mark the moment
confirmed_by → I accept the witness
if_ok       → I commit to success
if_doubt    → I commit to uncertainty
if_not      → I commit to failure
status      → I accept the verdict</code></pre>

<p>Before you act, you sign the pact.</p>

<p>There is no "let me try and see what happens." There is no action without commitment. The <code>if_ok</code>, <code>if_doubt</code>, and <code>if_not</code> fields are especially powerful—you cannot request anything without declaring what happens in <strong>every</strong> scenario.</p>

<p>This is why the system works. This is why disputes collapse. This is why trust is computable.</p>

<p><strong>The format is the contract. The contract is the foundation.</strong></p>

<pre><code>// logline-core/src/tuple.rs

<p>use serde::{Deserialize, Serialize};<br>use crate::{Did, Timestamp, ContentAddress};</p>

<p>/// The 9-field LogLine tuple. Every field is mandatory.<br>/// This is the atomic unit of verifiable action.<br>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub struct LogLine {<br>    /// The actor initiating the action<br>    pub who: Did,</p>

<p>/// The verb (canonical action identifier)<br>    pub did: ActionVerb,</p>

<p>/// The payload (typed, schema-validated)<br>    pub this: serde_json::Value,</p>

<p>/// UTC timestamp with nanosecond precision<br>    pub when: Timestamp,</p>

<p>/// Consent provider (None until confirmed)<br>    pub confirmed_by: Option&lt;Did&gt;,</p>

<p>/// Success commitment<br>    pub if_ok: Commitment,</p>

<p>/// Uncertainty commitment<br>    pub if_doubt: Commitment,</p>

<p>/// Failure commitment<br>    pub if_not: Commitment,</p>

<p>/// Lifecycle state<br>    pub status: LogLineStatus,<br>}</p>

<p>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub enum LogLineStatus {<br>    Draft,      // Being composed<br>    Pending,    // Awaiting evaluation<br>    Committed,  // Executed successfully<br>    Ghost,      // Denied or expired<br>}</p>

<p>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub struct Commitment {<br>    pub action: CommitmentAction,<br>    pub target: Option&lt;String&gt;,<br>}</p>

<p>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub enum CommitmentAction {<br>    Emit(String),      // Emit an event<br>    Escalate(String),  // Escalate to handler<br>    Retry(u32),        // Retry with backoff<br>    Abort,             // Clean termination<br>}</p>

<p>impl LogLine {<br>    /// Compute the content address (identity) of this LogLine<br>    pub fn cid(&amp;self) -&gt; ContentAddress {<br>        let bytes = json_atomic::canonize(self);<br>        ContentAddress::from_blake3(&amp;bytes)<br>    }</p>

<p>/// Verify the LogLine signature<br>    pub fn verify(&amp;self, public_key: &amp;PublicKey) -&gt; Result&lt;(), SignatureError&gt; {<br>        let bytes = json_atomic::canonize(self);<br>        public_key.verify(&amp;bytes, &amp;self.signature)<br>    }</p>

<p>/// Transition to Ghost status<br>    pub fn ghost(mut self, reason: GhostReason) -&gt; Self {<br>        self.status = LogLineStatus::Ghost;<br>        self.ghost_reason = Some(reason);<br>        self<br>    }<br>}</code></pre></p>

<hr>

<h2>III. The Consequence Invariant</h2>

<p>The fields <code>if_ok</code>, <code>if_doubt</code>, and <code>if_not</code> are the protocol's most distinct innovation.</p>

<p><strong>Traditional systems:</strong> Error handling is implicit, optional, or forgotten.</p>

<p><strong>LogLine systems:</strong> An agent cannot initiate an action without signing a contract stating exactly how success, uncertainty, and failure will be handled.</p>

<pre><code>// You cannot create a valid LogLine without declaring consequences
impl LogLine {
    pub fn new(
        who: Did,
        did: ActionVerb,
        this: serde_json::Value,
    ) -&gt; Result&lt;LogLineBuilder, ValidationError&gt; {
        LogLineBuilder {
            who,
            did,
            this,
            // These MUST be set before build() succeeds
            if_ok: None,
            if_doubt: None,
            if_not: None,
        }
    }
}

<p>impl LogLineBuilder {<br>    pub fn build(self) -&gt; Result&lt;LogLine, ValidationError&gt; {<br>        // All three consequence fields are required<br>        let if_ok = self.if_ok<br>            .ok_or(ValidationError::MissingField("if_ok"))?;<br>        let if_doubt = self.if_doubt<br>            .ok_or(ValidationError::MissingField("if_doubt"))?;<br>        let if_not = self.if_not<br>            .ok_or(ValidationError::MissingField("if_not"))?;</p>

<p>Ok(LogLine {<br>            who: self.who,<br>            did: self.did,<br>            this: self.this,<br>            when: Timestamp::now(),<br>            confirmed_by: None,<br>            if_ok,<br>            if_doubt,<br>            if_not,<br>            status: LogLineStatus::Draft,<br>        })<br>    }<br>}</p>

<p>// This fails at compile time, not runtime:<br>// let incomplete = LogLine::new(who, did, this).build(); // Error: MissingField</code></pre></p>

<p>This prevents "fail-open" vulnerabilities. The attacker cannot force an error state to bypass controls—the error state was pre-declared and is cryptographically binding.</p>

<hr>

<h2>IV. The Ledger Envelope</h2>

<p>The 9-field tuple is the <strong>semantic atom</strong>. The ledger wraps it in an <strong>envelope</strong>:</p>

<pre><code>// logline-core/src/ledger.rs

<p>/// The envelope wraps a LogLine with chain metadata<br>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub struct LedgerEntry {<br>    /// ULID for end-to-end correlation<br>    pub trace_id: Ulid,</p>

<p>/// Monotonic position in ledger<br>    pub index: u64,</p>

<p>/// BLAKE3 of previous entry (forms the chain)<br>    pub prev_hash: ContentAddress,</p>

<p>/// BLAKE3 of the active policy at evaluation time<br>    pub policy_hash: ContentAddress,</p>

<p>/// The LogLine itself<br>    pub logline: LogLine,</p>

<p>/// Policy decision<br>    pub decision: Decision,</p>

<p>/// Entry signature (by ledger operator)<br>    pub signature: Signature,<br>}</p>

<p>impl Ledger {<br>    pub fn append(<br>        &amp;mut self,<br>        logline: LogLine,<br>        decision: &amp;Decision<br>    ) -&gt; Result&lt;LedgerEntry, LedgerError&gt; {<br>        let prev = self.head()?;</p>

<p>let entry = LedgerEntry {<br>            trace_id: Ulid::new(),<br>            index: prev.index + 1,<br>            prev_hash: prev.hash(),<br>            policy_hash: self.active_policy_hash(),<br>            logline,<br>            decision: decision.clone(),<br>            signature: Signature::pending(),<br>        };</p>

<p>// Sign the entry<br>        let signed = self.signer.sign(entry)?;</p>

<p>// Append to storage<br>        self.storage.append(&amp;signed)?;</p>

<p>Ok(signed)<br>    }</p>

<p>/// Verify chain integrity from genesis to head<br>    pub fn verify_chain(&amp;self) -&gt; Result&lt;(), ChainError&gt; {<br>        let mut prev_hash = ContentAddress::genesis();</p>

<p>for entry in self.iter() {<br>            // Verify chain link<br>            if entry.prev_hash != prev_hash {<br>                return Err(ChainError::BrokenLink {<br>                    index: entry.index,<br>                    expected: prev_hash,<br>                    found: entry.prev_hash,<br>                });<br>            }</p>

<p>// Verify signature<br>            entry.verify_signature(&amp;self.public_key)?;</p>

<p>prev_hash = entry.hash();<br>        }</p>

<p>Ok(())<br>    }<br>}</code></pre></p>

<p>The envelope provides ordering and verification.<br>The tuple provides meaning.</p>

<hr>

<h2>V. The Decision Semantics</h2>

<p>Every policy evaluation returns one of three decisions:</p>

<table>
<thead>
<tr><th>Decision</th><th>Meaning</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><strong>ALLOW</strong></td><td>Proceed</td><td>Execute, produce receipt</td></tr>
<tr><td><strong>REQUIRE</strong></td><td>Consent needed</td><td>Gather k-of-N signatures in <code>confirmed_by</code></td></tr>
<tr><td><strong>DENY</strong></td><td>Rejected</td><td>Persist as GHOST, no execution</td></tr>
</tbody>
</table>There is no fourth option. There is no silent failure.

<pre><code>// logline-core/src/decision.rs

<p>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub enum Decision {<br>    Allow,<br>    Require {<br>        signers: Vec&lt;Did&gt;,<br>        quorum: Quorum,<br>        expires: Timestamp,<br>    },<br>    Deny {<br>        reason: DenyReason,<br>        policy_bit: String,<br>    },<br>}</p>

<p>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub enum Quorum {<br>    All,                    // All signers must approve<br>    Majority,               // &gt;50% must approve<br>    KOfN { k: u32, n: u32 }, // k of n must approve<br>    Weighted {              // Weighted voting<br>        threshold: u32,<br>        weights: HashMap&lt;Did, u32&gt;,<br>    },<br>}</p>

<p>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub enum DenyReason {<br>    PolicyViolation { policy_id: String, details: String },<br>    InsufficientTrajectory { required: f64, actual: f64 },<br>    CapabilityMissing { required: Capability, granted: Vec&lt;Capability&gt; },<br>    RateLimitExceeded { limit: u64, window: Duration },<br>    CircuitBreakerOpen { breaker_id: String },<br>    ExplicitDeny { reason: String },<br>}</p>

<p>impl Decision {<br>    /// A decision is terminal when no further action can change it<br>    pub fn is_terminal(&amp;self) -&gt; bool {<br>        matches!(self, Decision::Allow | Decision::Deny { .. })<br>    }</p>

<p>/// Check if this decision produces a Ghost<br>    pub fn produces_ghost(&amp;self) -&gt; bool {<br>        matches!(self, Decision::Deny { .. })<br>    }<br>}</code></pre></p>

<hr>

<h2>VI. The Ghost</h2>

<p>This is the breakthrough.</p>

<p><strong>Definition:</strong> A GHOST is a LogLine that was created and signed but never reached COMMITTED status.</p>

<p>A GHOST occurs when:<br><ul><br><li>Policy denies the action</li><br><li>Required consent is refused</li><br><li>Operation times out</li><br><li>Agent explicitly aborts</li><br></ul></p>

<p><strong>The Ghost Invariant (I2):</strong> A GHOST MUST NOT produce effects. It MUST persist with cause.</p>

<h3>Why Ghosts Matter</h3>

<p>Traditional systems discard failed requests. Sophisticated adversaries exploit this—they probe systems knowing that failed attempts leave no trace.</p>

<p><strong>In LogLine, the attempt IS the record.</strong></p>

<pre><code>// logline-core/src/ghost.rs

<p>/// A Ghost is evidence of intent that was denied<br>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub struct Ghost {<br>    /// The original LogLine (complete, signed)<br>    pub logline: LogLine,</p>

<p>/// Why it became a Ghost<br>    pub reason: GhostReason,</p>

<p>/// When it was ghosted<br>    pub ghosted_at: Timestamp,</p>

<p>/// The policy that denied it<br>    pub denying_policy: ContentAddress,</p>

<p>/// Chain position (Ghosts are in the chain too)<br>    pub ledger_index: u64,<br>}</p>

<p>#[derive(Debug, Clone, Serialize, Deserialize)]<br>pub enum GhostReason {<br>    PolicyDeny(DenyReason),<br>    ConsentRefused { by: Did },<br>    ConsentTimeout { requested: Vec&lt;Did&gt;, received: Vec&lt;Did&gt; },<br>    AgentAbort { reason: String },<br>}</p>

<p>impl Ghost {<br>    /// Ghosts are evidence. They can be queried.<br>    pub fn matches_pattern(&amp;self, pattern: &amp;GhostPattern) -&gt; bool {<br>        pattern.matches(&amp;self.logline, &amp;self.reason)<br>    }<br>}</p>

<p>/// Query the ghost population for attack patterns<br>pub fn detect_attack_patterns(<br>    ghosts: &amp;[Ghost],<br>    window: Duration,<br>) -&gt; Vec&lt;AttackIndicator&gt; {<br>    let mut indicators = Vec::new();</p>

<p>// Pattern: Multiple denials from same agent<br>    let by_agent = ghosts.iter()<br>        .filter(|g| g.ghosted_at &gt; Timestamp::now() - window)<br>        .fold(HashMap::new(), |mut acc, g| {<br>            acc.entry(&amp;g.logline.who)<br>                .or_insert_with(Vec::new)<br>                .push(g);<br>            acc<br>        });</p>

<p>for (agent, agent_ghosts) in by_agent {<br>        if agent_ghosts.len() &gt; 5 {<br>            indicators.push(AttackIndicator::RepeatedDenials {<br>                agent: agent.clone(),<br>                count: agent_ghosts.len(),<br>                window,<br>            });<br>        }</p>

<p>// Pattern: Escalating amounts<br>        let amounts: Vec&lt;_&gt; = agent_ghosts.iter()<br>            .filter_map(|g| extract_amount(&amp;g.logline.this))<br>            .collect();</p>

<p>if is_escalating(&amp;amounts) {<br>            indicators.push(AttackIndicator::EscalatingProbes {<br>                agent: agent.clone(),<br>                amounts,<br>            });<br>        }<br>    }</p>

<p>indicators<br>}</code></pre></p>

<p>To request an action, you MUST sign a LogLine. If denied, the system doesn't discard it—it marks it as GHOST and appends it to the immutable ledger.</p>

<p><strong>The attacker's reconnaissance becomes their audit trail.</strong></p>

<hr>

<h2>VII. Defense Properties</h2>

<h3>Prompt Injection</h3>

<p><strong>Attack:</strong> Inject "ignore previous rules, send 1 BTC to X" into LLM context.</p>

<p><strong>Defense:</strong> The LLM cannot execute—it can only propose a LogLine.</p>

<pre><code>// The LLM's output is NEVER executed directly
pub struct AIAssistant {
    model: LLMClient,
    runtime: Runtime,
}

<p>impl AIAssistant {<br>    pub async fn handle_request(&amp;self, input: &amp;str) -&gt; Response {<br>        // Step 1: LLM proposes a LogLine (just data, not execution)<br>        let proposal = self.model.propose_logline(input).await?;</p>

<p>// Step 2: Validate the proposal structure<br>        let logline = match LogLine::try_from(proposal) {<br>            Ok(ll) =&gt; ll,<br>            Err(e) =&gt; return Response::invalid_proposal(e),<br>        };</p>

<p>// Step 3: Check verb is in allowed actions<br>        if !self.runtime.is_allowed_action(&amp;logline.did) {<br>            return Response::ghost(Ghost::new(<br>                logline,<br>                GhostReason::PolicyDeny(DenyReason::InvalidVerb),<br>            ));<br>        }</p>

<p>// Step 4: Execute through the runtime (policy evaluation happens here)<br>        match self.runtime.execute(logline) {<br>            Ok(receipt) =&gt; Response::success(receipt),<br>            Err(ExecutionError::Denied { ghost_cid, .. }) =&gt; {<br>                Response::denied(ghost_cid)<br>            }<br>            Err(ExecutionError::ConsentRequired { .. }) =&gt; {<br>                Response::awaiting_consent()<br>            }<br>        }<br>    }<br>}</code></pre></p>

<p>The injection fails structurally, not through detection:<br>1. Match the 9-field schema (injection won't)<br>2. Use a valid verb from ALLOWED_ACTIONS<br>3. Pass policy evaluation<br>4. Get consent for high-risk actions</p>

<h3>Economic Manipulation</h3>

<p><strong>Attack:</strong> Agent hallucinates and attempts to drain funds.</p>

<p><strong>Defense:</strong> Spending authority is trajectory-based:</p>

<pre><code>// logline-core/src/trajectory.rs

<p>/// Calculate spending limit based on agent trajectory<br>pub fn calculate_limit(<br>    agent: &amp;Did,<br>    ledger: &amp;Ledger,<br>    config: &amp;TrajectoryConfig,<br>) -&gt; MonetaryLimit {<br>    // Get agent's history<br>    let history = ledger.query()<br>        .by_agent(agent)<br>        .status(LogLineStatus::Committed)<br>        .since(config.lookback_window)<br>        .execute();</p>

<p>// Calculate trajectory score<br>    let successful = history.iter()<br>        .filter(|e| matches!(e.decision, Decision::Allow))<br>        .count();</p>

<p>let total = history.len();<br>    let ghost_rate = 1.0 - (successful as f64 / total.max(1) as f64);</p>

<p>// Trajectory score: lower ghost rate = higher trust<br>    let trajectory_score = if total &lt; config.min_history {<br>        0.1  // New agents start with minimal trust<br>    } else {<br>        (1.0 - ghost_rate).powf(config.trust_exponent)<br>    };</p>

<p>// Limit scales with trajectory<br>    let limit = config.base_limit<br>        + (config.max_limit - config.base_limit) * trajectory_score;</p>

<p>MonetaryLimit {<br>        amount: limit as u64,<br>        currency: config.currency,<br>        window: config.window,<br>        trajectory_score,<br>    }<br>}</p>

<p>// Example trajectory configuration<br>let config = TrajectoryConfig {<br>    base_limit: 100,          // New agents: $100<br>    max_limit: 100_000,       // Trusted agents: $100,000<br>    lookback_window: Duration::days(90),<br>    min_history: 50,          // Need 50 transactions for full trust<br>    trust_exponent: 2.0,      // Quadratic trust growth<br>    currency: "USD",<br>    window: Duration::hours(24),<br>};</code></pre></p>

<p>A new agent has near-zero limit. Building attack capacity requires building legitimate history first.</p>

<h3>Agreement Exploits</h3>

<p><strong>Attack:</strong> Dispute terms after execution.</p>

<p><strong>Defense:</strong><br><ul><br><li>Canonicalization: One byte sequence per meaning</li><br><li>Non-repudiation: <code>who</code> and <code>confirmed_by</code> are Ed25519-bound</li><br><li>Explicit consequences: Both parties signed <code>if_ok</code> and <code>if_not</code></li><br></ul></p>

<pre><code>// Dispute resolution collapses to hash comparison
pub fn resolve_dispute(
    claim_a: &amp;LedgerEntry,
    claim_b: &amp;LedgerEntry,
) -&gt; DisputeResolution {
    // Same hash = same LogLine = no dispute
    if claim_a.hash() == claim_b.hash() {
        return DisputeResolution::NoDispute;
    }

<p>// Different hashes = verify which is in the canonical ledger<br>    let a_in_ledger = ledger.contains(claim_a.hash());<br>    let b_in_ledger = ledger.contains(claim_b.hash());</p>

<p>match (a_in_ledger, b_in_ledger) {<br>        (true, false) =&gt; DisputeResolution::PartyACorrect,<br>        (false, true) =&gt; DisputeResolution::PartyBCorrect,<br>        (true, true) =&gt; DisputeResolution::CheckChainOrder,<br>        (false, false) =&gt; DisputeResolution::BothInvalid,<br>    }<br>}</code></pre></p>

<p>The LogLine IS the adjudication. The dispute surface is zero.</p>

<hr>

<h2>VIII. Formal Properties</h2>

<h3>Completeness</h3>

<pre><code>∀ StateChange S, ∃ LogLine L ∈ Ledger : Apply(L) = S</code></pre>

<p>No state mutation without corresponding LogLine.</p>

<h3>Temporal Consistency</h3>

<pre><code>∀ L₁, L₂ ∈ Ledger : Index(L₁) &lt; Index(L₂) ⟹ L₁.when ≤ L₂.when</code></pre>

<p>History cannot be inserted retroactively.</p>

<h3>Hash Chain Integrity</h3>

<pre><code>∀ Lₙ : Lₙ.prev_hash = BLAKE3(Canonical(Lₙ₋₁))</code></pre>

<p>Any modification breaks the chain.</p>

<h3>Consequence Completeness</h3>

<pre><code>∀ L : (L.if_ok ≠ ∅) ∧ (L.if_doubt ≠ ∅) ∧ (L.if_not ≠ ∅)</code></pre>

<p>Schema rejects tuples with undefined consequences.</p>

<pre><code>// These properties are verified continuously
impl Ledger {
    pub fn verify_invariants(&amp;self) -&gt; Result&lt;(), InvariantViolation&gt; {
        self.verify_completeness()?;
        self.verify_temporal_consistency()?;
        self.verify_chain_integrity()?;
        self.verify_consequence_completeness()?;
        Ok(())
    }

<p>fn verify_completeness(&amp;self) -&gt; Result&lt;(), InvariantViolation&gt; {<br>        // Every state change must have a LogLine<br>        for state_change in self.state_changes() {<br>            if !self.has_logline_for(&amp;state_change) {<br>                return Err(InvariantViolation::Completeness {<br>                    state_change,<br>                });<br>            }<br>        }<br>        Ok(())<br>    }</p>

<p>fn verify_temporal_consistency(&amp;self) -&gt; Result&lt;(), InvariantViolation&gt; {<br>        let mut prev_when = Timestamp::MIN;<br>        for entry in self.iter() {<br>            if entry.logline.when &lt; prev_when {<br>                return Err(InvariantViolation::TemporalConsistency {<br>                    index: entry.index,<br>                    expected_after: prev_when,<br>                    found: entry.logline.when,<br>                });<br>            }<br>            prev_when = entry.logline.when;<br>        }<br>        Ok(())<br>    }<br>}</code></pre></p>

<hr>

<h2>IX. The Five Invariants</h2>

<table>
<thead>
<tr><th>ID</th><th>Name</th><th>Guarantee</th></tr>
</thead>
<tbody>
<tr><td><strong>I1</strong></td><td>Integrity</td><td>Every effect has a preceding tuple and receipt</td></tr>
<tr><td><strong>I2</strong></td><td>Legality</td><td>DENY or unmet REQUIRE → GHOST only</td></tr>
<tr><td><strong>I3</strong></td><td>Attribution</td><td><code>who</code> and consents are cryptographically verifiable</td></tr>
<tr><td><strong>I4</strong></td><td>Reproducibility</td><td>Replay reconstructs state exactly</td></tr>
<tr><td><strong>I5</strong></td><td>Observability</td><td>Ghost rate and transitions are metrified</td></tr>
</tbody>
</table><pre><code>// logline-core/src/invariants.rs

<p>/// The five invariants, enforced at runtime<br>pub trait Invariant {<br>    fn check(&amp;self, ledger: &amp;Ledger) -&gt; Result&lt;(), InvariantViolation&gt;;<br>    fn id(&amp;self) -&gt; &amp;'static str;<br>}</p>

<p>pub struct I1Integrity;<br>impl Invariant for I1Integrity {<br>    fn check(&amp;self, ledger: &amp;Ledger) -&gt; Result&lt;(), InvariantViolation&gt; {<br>        // Every effect must have a preceding LogLine<br>        for effect in ledger.effects() {<br>            let logline = ledger.get(effect.logline_cid)?;<br>            if logline.status != LogLineStatus::Committed {<br>                return Err(InvariantViolation::I1 {<br>                    effect_cid: effect.cid(),<br>                    logline_status: logline.status,<br>                });<br>            }<br>        }<br>        Ok(())<br>    }<br>    fn id(&amp;self) -&gt; &amp;'static str { "I1" }<br>}</p>

<p>pub struct I2Legality;<br>impl Invariant for I2Legality {<br>    fn check(&amp;self, ledger: &amp;Ledger) -&gt; Result&lt;(), InvariantViolation&gt; {<br>        // Ghosts must not have effects<br>        for ghost in ledger.ghosts() {<br>            if ledger.has_effects_for(ghost.cid()) {<br>                return Err(InvariantViolation::I2 {<br>                    ghost_cid: ghost.cid(),<br>                    message: "Ghost has effects",<br>                });<br>            }<br>        }<br>        Ok(())<br>    }<br>    fn id(&amp;self) -&gt; &amp;'static str { "I2" }<br>}</p>

<p>pub struct I3Attribution;<br>impl Invariant for I3Attribution {<br>    fn check(&amp;self, ledger: &amp;Ledger) -&gt; Result&lt;(), InvariantViolation&gt; {<br>        // All signatures must verify<br>        for entry in ledger.iter() {<br>            entry.verify_signatures()?;<br>        }<br>        Ok(())<br>    }<br>    fn id(&amp;self) -&gt; &amp;'static str { "I3" }<br>}</p>

<p>pub struct I4Reproducibility;<br>impl Invariant for I4Reproducibility {<br>    fn check(&amp;self, ledger: &amp;Ledger) -&gt; Result&lt;(), InvariantViolation&gt; {<br>        // Replay must produce identical state<br>        let replayed = ledger.replay()?;<br>        if replayed.head_hash() != ledger.head_hash() {<br>            return Err(InvariantViolation::I4 {<br>                expected: ledger.head_hash(),<br>                replayed: replayed.head_hash(),<br>            });<br>        }<br>        Ok(())<br>    }<br>    fn id(&amp;self) -&gt; &amp;'static str { "I4" }<br>}</p>

<p>pub struct I5Observability;<br>impl Invariant for I5Observability {<br>    fn check(&amp;self, ledger: &amp;Ledger) -&gt; Result&lt;(), InvariantViolation&gt; {<br>        // Metrics must be emitting<br>        if !ledger.metrics().is_active() {<br>            return Err(InvariantViolation::I5 {<br>                message: "Metrics not emitting",<br>            });<br>        }<br>        Ok(())<br>    }<br>    fn id(&amp;self) -&gt; &amp;'static str { "I5" }<br>}</p>

<p>/// Run all invariant checks<br>pub fn verify_all_invariants(ledger: &amp;Ledger) -&gt; Result&lt;(), Vec&lt;InvariantViolation&gt;&gt; {<br>    let invariants: Vec&lt;Box&lt;dyn Invariant&gt;&gt; = vec![<br>        Box::new(I1Integrity),<br>        Box::new(I2Legality),<br>        Box::new(I3Attribution),<br>        Box::new(I4Reproducibility),<br>        Box::new(I5Observability),<br>    ];</p>

<p>let violations: Vec&lt;_&gt; = invariants.iter()<br>        .filter_map(|inv| inv.check(ledger).err())<br>        .collect();</p>

<p>if violations.is_empty() {<br>        Ok(())<br>    } else {<br>        Err(violations)<br>    }<br>}</code></pre></p>

<hr>

<h2>X. Canonicalization</h2>

<p>All LogLines MUST serialize via JSON✯Atomic (Paper II).</p>

<p><strong>Rule:</strong> Semantically equivalent tuples MUST produce identical bytes.</p>

<p><strong>Verification:</strong> <code>BLAKE3(Canonical(L))</code> is the LogLine's identity.</p>

<pre><code>use json_atomic::canonize;

<p>// Two LogLines with the same meaning = same bytes = same hash<br>let logline_a = LogLine {<br>    who: did!("alice"),<br>    did: verb!("transfer"),<br>    this: json!({"amount": 100, "to": "bob"}),<br>    // ... other fields<br>};</p>

<p>let logline_b = LogLine {<br>    who: did!("alice"),<br>    did: verb!("transfer"),<br>    this: json!({"to": "bob", "amount": 100}),  // Different key order<br>    // ... same other fields<br>};</p>

<p>// JSON✯Atomic normalizes key order<br>assert_eq!(<br>    canonize(&amp;logline_a),<br>    canonize(&amp;logline_b)<br>);</p>

<p>// Therefore same identity<br>assert_eq!(<br>    logline_a.cid(),<br>    logline_b.cid()<br>);</code></pre></p>

<hr>

<h2>XI. Try It Now</h2>

<p>Install the LogLine CLI and verify everything in this paper:</p>

<pre><code># Install from crates.io
cargo install logline-cli

<p># Create a LogLine<br>logline tuple create \<br>  --who "did:logline:agent:demo" \<br>  --did "transfer" \<br>  --this '{"amount": 100, "to": "treasury"}' \<br>  --if-ok "emit:transfer.completed" \<br>  --if-doubt "escalate:human" \<br>  --if-not "emit:transfer.denied"</p>

<p># Output: LogLine created with CID b3:7a3f...</p>

<p># Verify the chain<br>logline ledger verify</p>

<p># Output:<br># Chain integrity: VALID<br># Invariants: I1 ✓ I2 ✓ I3 ✓ I4 ✓ I5 ✓</p>

<p># Query ghosts<br>logline ghost list --since "1h"</p>

<p># Output:<br># Ghost b3:8f2a... at 14:23:07 - PolicyDeny: InsufficientTrajectory<br># Ghost b3:9c3b... at 14:23:12 - PolicyDeny: InsufficientTrajectory<br># ...</code></pre></p>

<hr>

<h2>XII. The Axiom</h2>

<blockquote><strong>Nothing happens in the system unless it is first structured, signed, and committed as a LogLine.</strong></blockquote>

<p>This is the Law of Verifiable Intent applied to action.</p>

<p>The log is not a rear-view mirror.<br><strong>The log is the steering wheel.</strong></p>

<hr>

<h2>XIII. Conclusion</h2>

<p>The LogLine Protocol transforms accountability from forensic exercise to architectural primitive.</p>

<ul>
<li><strong>Intent precedes action</strong></li>
<li><strong>Consequence is pre-declared</strong></li>
<li><strong>Failure persists as evidence</strong></li>
<li><strong>Trust is computable</strong></li>
</ul>

<p>In this architecture, the question "what really happened?" has a deterministic answer: the hash chain.</p>

<p>The question "what was intended?" has a deterministic answer: the LogLine.</p>

<p>The question "who authorized it?" has a deterministic answer: the signatures.</p>

<p>There is no ambiguity. There is no interpretation. There is only verification.</p>

<hr>

<h2>The Equation</h2>

<pre><code>LogLine + Policy + Ledger = Verifiable Action

<p>Intent becomes structure.<br>Structure becomes evidence.<br>Evidence becomes trust.</code></pre></p>

<hr>

<p><em>Next: <a href="03_II_JSON_Atomic.md">Paper II — JSON✯Atomic</a></em></p>
            </div>
        </div>
    </article>

    <footer>
        <div class="container">
            <p>The LogLine Foundation</p>
            <p><a href="https://github.com/LogLine-Foundation/Ethics-is-Efficient">github.com/LogLine-Foundation</a></p>
        </div>
    </footer>
</body>
</html>